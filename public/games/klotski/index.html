<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Klotski - Classic Sliding Block Puzzle</title>
  <style>
    body {
      font-family: 'Microsoft YaHei', 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background-color: #0f172a;
      color: #f8fafc;
      margin: 0;
      padding: 0;
      display: flex;
      justify-content: center;
      align-items: center;
      min-height: 100vh;
    }
    
    .game-container {
      background-color: #1e293b;
      border-radius: 1rem;
      padding: 2rem;
      width: 90%;
      max-width: 800px;
      box-shadow: 0 10px 25px rgba(0, 0, 0, 0.5);
      text-align: center;
    }
    
    h1 {
      color: #d97706;
      margin-top: 0;
      font-size: 2rem;
      text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.3);
    }
    
    .game-description {
      margin-bottom: 1.5rem;
      color: #cbd5e1;
      line-height: 1.6;
      position: relative;
    }
    
    .text-button {
      background: none;
      border: none;
      color: #3b82f6;
      padding: 0;
      font-size: 0.9rem;
      cursor: pointer;
      text-decoration: underline;
      margin-top: 0.5rem;
    }
    
    .text-button:hover {
      color: #60a5fa;
      background: none;
    }
    
    .rules-panel {
      display: none;
      position: absolute;
      left: 0;
      right: 0;
      background-color: #1e293b;
      border: 1px solid #475569;
      border-radius: 0.5rem;
      padding: 1rem;
      margin-top: 0.5rem;
      text-align: left;
      z-index: 50;
      max-height: 70vh;
      overflow-y: auto;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
    }
    
    .rules-panel.show {
      display: block;
    }
    
    .rules-panel h3 {
      color: #d97706;
      margin-top: 0;
      border-bottom: 1px solid #475569;
      padding-bottom: 0.5rem;
    }
    
    .rules-panel ul {
      padding-left: 1.5rem;
      margin-bottom: 1rem;
    }
    
    .rules-panel li {
      margin-bottom: 0.5rem;
    }
    
    .rules-panel ul ul {
      margin-top: 0.5rem;
      margin-bottom: 0.5rem;
    }
    
    #close-rules-btn {
      background-color: #475569;
      padding: 0.5rem 1rem;
      font-size: 0.9rem;
      margin-top: 0.5rem;
    }
    
    .klotski-board {
      position: relative;
      width: 320px;
      height: 400px;
      margin: 0 auto;
      background-color: #7c2d12;
      border: 8px solid #92400e;
      border-radius: 8px;
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
      overflow: hidden;
    }
    
    .block {
      position: absolute;
      background: linear-gradient(135deg, #fbbf24, #d97706);
      border-radius: 4px;
      box-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3), inset 1px 1px 1px rgba(255, 255, 255, 0.3);
      cursor: pointer;
      transition: transform 0.2s, box-shadow 0.2s;
      display: flex;
      justify-content: center;
      align-items: center;
      font-weight: bold;
      color: #7c2d12;
      border: 2px solid #92400e;
      box-sizing: border-box;
    }
    
    .block:hover {
      box-shadow: 3px 3px 6px rgba(0, 0, 0, 0.4), inset 1px 1px 1px rgba(255, 255, 255, 0.4);
      z-index: 10;
    }
    
    .block:active {
      transform: scale(0.98);
    }
    
    .block.cao-cao {
      background: linear-gradient(135deg, #f59e0b, #b45309);
      color: #fef3c7;
      font-size: 24px;
    }
    
    .block.general {
      background: linear-gradient(135deg, #f87171, #b91c1c);
      color: #fee2e2;
    }
    
    .block.soldier {
      background: linear-gradient(135deg, #60a5fa, #2563eb);
      color: #dbeafe;
    }
    
    .block.vertical {
      background: linear-gradient(135deg, #34d399, #059669);
      color: #d1fae5;
    }
    
    .exit {
      position: absolute;
      bottom: 0;
      left: 50%;
      transform: translateX(-50%);
      width: 80px;
      height: 20px;
      background-color: #fef3c7;
      border-top-left-radius: 20px;
      border-top-right-radius: 20px;
      border: 2px solid #92400e;
      border-bottom: none;
      color: #92400e;
      font-size: 12px;
      display: flex;
      justify-content: center;
      align-items: center;
    }
    
    .controls {
      margin-top: 1.5rem;
      display: flex;
      justify-content: center;
      gap: 1rem;
      flex-wrap: wrap;
    }
    
    button {
      background-color: #b45309;
      color: white;
      border: none;
      border-radius: 0.5rem;
      padding: 0.75rem 1.5rem;
      font-size: 1rem;
      cursor: pointer;
      transition: background-color 0.3s;
    }
    
    button:hover {
      background-color: #92400e;
    }
    
    select {
      padding: 0.5rem;
      border-radius: 0.25rem;
      background-color: #1e293b;
      color: #f8fafc;
      border: 1px solid #475569;
    }
    
    .level-select {
      margin-top: 1.5rem;
      margin-bottom: 1.5rem;
    }
    
    .stats {
      margin-top: 1.5rem;
      display: flex;
      justify-content: space-around;
      background-color: #334155;
      padding: 0.75rem;
      border-radius: 0.5rem;
    }
    
    .victory-message {
      display: none;
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background-color: rgba(30, 41, 59, 0.9);
      padding: 2rem;
      border-radius: 1rem;
      text-align: center;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
      z-index: 100;
    }
    
    .victory-message h2 {
      color: #fbbf24;
      margin-top: 0;
    }
    
    .show {
      display: block;
    }
  </style>
</head>
<body>
  <div class="game-container">
    <h1>Klotski</h1>
    
    <div class="game-description">
      <p>Klotski is an ancient sliding block puzzle. Move the blocks to help the largest block (the red one) escape through the exit at the bottom.</p>
      <button id="rules-btn" class="text-button">View Rules</button>
      <div id="rules-panel" class="rules-panel">
        <h3>Game Rules</h3>
        <ul>
          <li><strong>Goal:</strong> Move the large red block to the exit at the bottom center of the board.</li>
          <li><strong>How to Play:</strong>
            <ul>
              <li>Click on a block, then drag it or use arrow keys to move it</li>
              <li>On mobile, you can touch and drag blocks</li>
            </ul>
          </li>
          <li><strong>Movement Rules:</strong>
            <ul>
              <li>Blocks can only move horizontally or vertically</li>
              <li>Blocks cannot jump over or cover other blocks</li>
              <li>Blocks cannot move outside the board</li>
            </ul>
          </li>
          <li><strong>Block Types:</strong>
            <ul>
              <li>Red Block: 2×2 large block - the one you need to move to the exit</li>
              <li>Horizontal Block: 2×1 horizontal block</li>
              <li>Vertical Block: 1×2 vertical block</li>
              <li>Small Block: 1×1 small square block</li>
            </ul>
          </li>
          <li><strong>Layouts:</strong>
            <ul>
              <li>Classic: Traditional layout, medium difficulty</li>
              <li>Surrounded: The red block is surrounded, harder</li>
              <li>Challenge: Enemy blocks everywhere, medium difficulty</li>
              <li>Hard Mode: Many obstacles, very difficult</li>
            </ul>
          </li>
        </ul>
        <button id="close-rules-btn">Close</button>
      </div>
    </div>

    <div class="level-select">
      <label for="layout-select">Select Layout:</label>
      <select id="layout-select">
        <option value="horizontal-vertical">Classic</option>
        <option value="surrounded">Surrounded</option>
        <option value="huarong-road">Challenge</option>
        <option value="tight-encirclement">Hard Mode</option>
      </select>
      <button id="start-layout">Start</button>
    </div>
    
    <div class="klotski-board" id="game-board">
      <!-- Blocks will be generated by JavaScript -->
      <div class="exit">Exit</div>
    </div>
    
    <div class="stats">
      <div class="moves">Moves: <span id="moves-count">0</span></div>
      <div class="timer">Time: <span id="timer">00:00</span></div>
    </div>
    
    <div class="controls">
      <button id="reset-btn">Reset</button>
      <button id="hint-btn">Hint</button>
      <button id="undo-btn">Undo</button>
    </div>
    
    <div class="victory-message" id="victory-message">
      <h2>Congratulations!</h2>
      <p>You helped the red block escape!</p>
      <p>Moves: <span id="victory-moves">0</span></p>
      <p>Time: <span id="victory-time">00:00</span></p>
      <button id="play-again-btn">Play Again</button>
    </div>
  </div>

  <script>
    // Game basic data
    const CELL_SIZE = 80;  // Cell size
    const GRID_ROWS = 5;   // Board rows
    const GRID_COLS = 4;   // Board columns
    
    // Block types
    const BLOCK_TYPES = {
      CAO_CAO: { width: 2, height: 2, className: 'cao-cao', label: 'Red Block' },
      HORIZONTAL: { width: 2, height: 1, className: 'general', label: 'H-Block' },
      VERTICAL: { width: 1, height: 2, className: 'vertical', label: 'V-Block' },
      SOLDIER: { width: 1, height: 1, className: 'soldier', label: 'Small' }
    };
    
    // Game layout presets
    const LAYOUTS = {
      'horizontal-vertical': [
        { type: BLOCK_TYPES.CAO_CAO, x: 1, y: 0 },
        { type: BLOCK_TYPES.HORIZONTAL, x: 0, y: 2 },
        { type: BLOCK_TYPES.HORIZONTAL, x: 2, y: 2 },
        { type: BLOCK_TYPES.VERTICAL, x: 0, y: 0 },
        { type: BLOCK_TYPES.VERTICAL, x: 3, y: 0 },
        { type: BLOCK_TYPES.VERTICAL, x: 0, y: 3 },
        { type: BLOCK_TYPES.VERTICAL, x: 3, y: 3 },
        { type: BLOCK_TYPES.SOLDIER, x: 1, y: 3 },
        { type: BLOCK_TYPES.SOLDIER, x: 2, y: 3 },
        { type: BLOCK_TYPES.SOLDIER, x: 1, y: 4 },
        { type: BLOCK_TYPES.SOLDIER, x: 2, y: 4 }
      ],
      'surrounded': [
        { type: BLOCK_TYPES.CAO_CAO, x: 1, y: 0 },
        { type: BLOCK_TYPES.HORIZONTAL, x: 1, y: 2 },
        { type: BLOCK_TYPES.VERTICAL, x: 0, y: 0 },
        { type: BLOCK_TYPES.VERTICAL, x: 3, y: 0 },
        { type: BLOCK_TYPES.VERTICAL, x: 0, y: 2 },
        { type: BLOCK_TYPES.VERTICAL, x: 3, y: 2 },
        { type: BLOCK_TYPES.SOLDIER, x: 1, y: 3 },
        { type: BLOCK_TYPES.SOLDIER, x: 2, y: 3 },
        { type: BLOCK_TYPES.SOLDIER, x: 0, y: 4 },
        { type: BLOCK_TYPES.SOLDIER, x: 1, y: 4 },
        { type: BLOCK_TYPES.SOLDIER, x: 2, y: 4 },
        { type: BLOCK_TYPES.SOLDIER, x: 3, y: 4 }
      ],
      'huarong-road': [
        { type: BLOCK_TYPES.CAO_CAO, x: 1, y: 0 },
        { type: BLOCK_TYPES.HORIZONTAL, x: 1, y: 2 },
        { type: BLOCK_TYPES.VERTICAL, x: 0, y: 0 },
        { type: BLOCK_TYPES.VERTICAL, x: 3, y: 0 },
        { type: BLOCK_TYPES.VERTICAL, x: 0, y: 2 },
        { type: BLOCK_TYPES.VERTICAL, x: 3, y: 2 },
        { type: BLOCK_TYPES.SOLDIER, x: 0, y: 4 },
        { type: BLOCK_TYPES.SOLDIER, x: 1, y: 3 },
        { type: BLOCK_TYPES.SOLDIER, x: 2, y: 3 },
        { type: BLOCK_TYPES.SOLDIER, x: 3, y: 4 }
      ],
      'tight-encirclement': [
        { type: BLOCK_TYPES.CAO_CAO, x: 1, y: 1 },
        { type: BLOCK_TYPES.HORIZONTAL, x: 1, y: 3 },
        { type: BLOCK_TYPES.VERTICAL, x: 0, y: 0 },
        { type: BLOCK_TYPES.VERTICAL, x: 3, y: 0 },
        { type: BLOCK_TYPES.SOLDIER, x: 1, y: 0 },
        { type: BLOCK_TYPES.SOLDIER, x: 2, y: 0 },
        { type: BLOCK_TYPES.SOLDIER, x: 0, y: 2 },
        { type: BLOCK_TYPES.SOLDIER, x: 3, y: 2 },
        { type: BLOCK_TYPES.SOLDIER, x: 0, y: 3 },
        { type: BLOCK_TYPES.SOLDIER, x: 3, y: 3 }
      ]
    };
    
    // Game state variables
    let blocks = [];
    let selectedBlock = null;
    let moveCount = 0;
    let startTime = null;
    let timerInterval = null;
    let gameActive = false;
    let moveHistory = [];
    let currentLayout = 'horizontal-vertical';  // Current layout
    let isDragging = false;
    let lastMoveTime = 0;
    
    // DOM element references
    const gameBoard = document.getElementById('game-board');
    const movesCount = document.getElementById('moves-count');
    const timerDisplay = document.getElementById('timer');
    const layoutSelect = document.getElementById('layout-select');
    const startLayoutButton = document.getElementById('start-layout');
    const resetButton = document.getElementById('reset-btn');
    const hintButton = document.getElementById('hint-btn');
    const undoButton = document.getElementById('undo-btn');
    const victoryMessage = document.getElementById('victory-message');
    const victoryMoves = document.getElementById('victory-moves');
    const victoryTime = document.getElementById('victory-time');
    const playAgainButton = document.getElementById('play-again-btn');
    const rulesButton = document.getElementById('rules-btn');
    const rulesPanel = document.getElementById('rules-panel');
    const closeRulesButton = document.getElementById('close-rules-btn');
    
    // Initialize layout
    function initLayout(layoutName) {
      console.log("Initializing layout:", layoutName);
      
      // Clear previous blocks
      gameBoard.querySelectorAll('.block').forEach(block => {
        block.remove();
      });
      
      // Remove all event listeners
      document.removeEventListener('keydown', handleKeyDown);
      document.removeEventListener('mousemove', handleMouseMove);
      document.removeEventListener('mouseup', handleMouseUp);
      gameBoard.removeEventListener('touchmove', handleTouchMove);
      gameBoard.removeEventListener('touchend', handleTouchEnd);
      
      // Reset game state
      blocks = [];
      selectedBlock = null;
      moveCount = 0;
      movesCount.textContent = '0';
      moveHistory = [];
      currentLayout = layoutName;
      isDragging = false;
      
      // Stop and reset timer
      if (timerInterval) {
        clearInterval(timerInterval);
        timerInterval = null;
      }
      startTime = new Date();
      timerDisplay.textContent = '00:00';
      
      // Load selected layout
      const layout = LAYOUTS[layoutName];
      layout.forEach((blockData, index) => {
        const block = createBlock(blockData, index);
        blocks.push(block);
        gameBoard.appendChild(block.element);
      });
      
      // Start timer
      startTimer();
      
      // Bind global event listeners
      document.addEventListener('keydown', handleKeyDown);
      
      // Set game state to active
      gameActive = true;
      victoryMessage.classList.remove('show');
      
      console.log("Game initialized, block count:", blocks.length);
    }
    
    // Create a block
    function createBlock(blockData, id) {
      const { type, x, y } = blockData;
      const element = document.createElement('div');
      element.className = `block ${type.className}`;
      element.textContent = type.label;
      element.style.width = `${type.width * CELL_SIZE}px`;
      element.style.height = `${type.height * CELL_SIZE}px`;
      element.style.left = `${x * CELL_SIZE}px`;
      element.style.top = `${y * CELL_SIZE}px`;
      
      // Set block data attribute for debugging
      element.setAttribute('data-id', id);
      
      // Set click event
      element.addEventListener('mousedown', handleBlockMouseDown);
      element.addEventListener('touchstart', handleBlockTouchStart);
      
      return {
        id,
        type,
        x,
        y,
        element
      };
    }
    
    // Handle block mouse down event
    function handleBlockMouseDown(e) {
      console.log("Block clicked");
      
      if (!gameActive) return;
      
      const id = parseInt(this.getAttribute('data-id'));
      selectBlock(id);
      
      isDragging = true;
      document.addEventListener('mousemove', handleMouseMove);
      document.addEventListener('mouseup', handleMouseUp);
      
      e.preventDefault(); // Prevent dragging selected text
    }
    
    // Handle block touch start event
    function handleBlockTouchStart(e) {
      console.log("Block touched");
      
      if (!gameActive) return;
      
      const id = parseInt(this.getAttribute('data-id'));
      selectBlock(id);
      
      isDragging = true;
      gameBoard.addEventListener('touchmove', handleTouchMove);
      gameBoard.addEventListener('touchend', handleTouchEnd);
      
      e.preventDefault(); // Prevent default touch behavior
    }
    
    // Select a block
    function selectBlock(id) {
      console.log("Selecting block:", id);
      
      // Cancel previous selection
      if (selectedBlock !== null && blocks[selectedBlock]) {
        blocks[selectedBlock].element.style.boxShadow = '';
        blocks[selectedBlock].element.style.zIndex = '';
      }
      
      selectedBlock = id;
      
      // Highlight selected block
      if (blocks[selectedBlock]) {
        blocks[selectedBlock].element.style.boxShadow = '0 0 10px 3px rgba(250, 204, 21, 0.7)';
        blocks[selectedBlock].element.style.zIndex = '20';
      }
    }
    
    // Handle keyboard key
    function handleKeyDown(e) {
      if (selectedBlock === null || !gameActive || !blocks[selectedBlock]) return;
      
      console.log("Keyboard key:", e.key);
      
      let deltaX = 0;
      let deltaY = 0;
      
      // Ensure some interval between key presses to prevent rapid continuous movement
      const now = Date.now();
      if (now - lastMoveTime < 100) return;
      lastMoveTime = now;
      
      switch (e.key) {
        case 'ArrowUp':
          deltaY = -1;
          break;
        case 'ArrowDown':
          deltaY = 1;
          break;
        case 'ArrowLeft':
          deltaX = -1;
          break;
        case 'ArrowRight':
          deltaX = 1;
          break;
        default:
          return;
      }
      
      if (deltaX !== 0 || deltaY !== 0) {
        if (tryMoveBlock(selectedBlock, deltaX, deltaY)) {
          e.preventDefault(); // Prevent page scrolling
        }
      }
    }
    
    // Handle mouse move
    function handleMouseMove(e) {
      if (!isDragging || selectedBlock === null || !gameActive || !blocks[selectedBlock]) return;
      
      const block = blocks[selectedBlock];
      const rect = gameBoard.getBoundingClientRect();
      
      // Calculate mouse position on the game board (in cell units)
      const mouseX = Math.floor((e.clientX - rect.left) / CELL_SIZE);
      const mouseY = Math.floor((e.clientY - rect.top) / CELL_SIZE);
      
      moveBlockTowardPosition(mouseX, mouseY);
    }
    
    // Handle touch move
    function handleTouchMove(e) {
      if (!isDragging || selectedBlock === null || !gameActive || !blocks[selectedBlock]) return;
      
      const touch = e.touches[0];
      const rect = gameBoard.getBoundingClientRect();
      
      // Calculate touch position on the game board (in cell units)
      const touchX = Math.floor((touch.clientX - rect.left) / CELL_SIZE);
      const touchY = Math.floor((touch.clientY - rect.top) / CELL_SIZE);
      
      moveBlockTowardPosition(touchX, touchY);
      
      e.preventDefault(); // Prevent page scrolling etc
    }
    
    // Move block toward target position
    function moveBlockTowardPosition(targetX, targetY) {
      const block = blocks[selectedBlock];
      
      // If already at target position, no need to move
      if (block.x === targetX && block.y === targetY) return;
      
      // Calculate movement direction
      const deltaX = Math.sign(targetX - block.x);
      const deltaY = Math.sign(targetY - block.y);
      
      // Prioritize horizontal movement
      if (deltaX !== 0 && tryMoveBlock(selectedBlock, deltaX, 0)) {
        return;
      }
      
      // Then try vertical movement
      if (deltaY !== 0 && tryMoveBlock(selectedBlock, 0, deltaY)) {
        return;
      }
    }
    
    // Handle mouse up
    function handleMouseUp() {
      console.log("Mouse up");
      isDragging = false;
      document.removeEventListener('mousemove', handleMouseMove);
      document.removeEventListener('mouseup', handleMouseUp);
      // Keep block selected, don't clear selectedBlock
    }
    
    // Handle touch end
    function handleTouchEnd() {
      console.log("Touch end");
      isDragging = false;
      gameBoard.removeEventListener('touchmove', handleTouchMove);
      gameBoard.removeEventListener('touchend', handleTouchEnd);
      // Keep block selected, don't clear selectedBlock
    }
    
    // Try moving block
    function tryMoveBlock(blockId, deltaX, deltaY) {
      if (!blocks[blockId]) {
        console.error("Trying to move non-existent block:", blockId);
        return false;
      }
      
      const block = blocks[blockId];
      const newX = block.x + deltaX;
      const newY = block.y + deltaY;
      
      console.log(`Trying to move block ${blockId} from (${block.x},${block.y}) to (${newX},${newY})`);
      
      // Check boundaries
      if (newX < 0 || newY < 0 || 
          newX + block.type.width > GRID_COLS || 
          newY + block.type.height > GRID_ROWS) {
        console.log("Movement failed: out of bounds");
        return false;
      }
      
      // Check collision
      for (let i = 0; i < blocks.length; i++) {
        if (i === blockId || !blocks[i]) continue;
        
        const otherBlock = blocks[i];
        
        // Check if two blocks overlap
        if (newX < otherBlock.x + otherBlock.type.width &&
            newX + block.type.width > otherBlock.x &&
            newY < otherBlock.y + otherBlock.type.height &&
            newY + block.type.height > otherBlock.y) {
          console.log(`Movement failed: collision with block ${i}`);
          return false;
        }
      }
      
      // Save movement history
      moveHistory.push({
        blockId,
        fromX: block.x,
        fromY: block.y,
        toX: newX,
        toY: newY
      });
      
      // Move block
      block.x = newX;
      block.y = newY;
      block.element.style.left = `${newX * CELL_SIZE}px`;
      block.element.style.top = `${newY * CELL_SIZE}px`;
      
      // Update movement count
      moveCount++;
      movesCount.textContent = moveCount;
      
      console.log("Movement successful");
      
      // Check victory condition
      checkVictory();
      
      return true;
    }
    
    // Check victory condition
    function checkVictory() {
      // Find red block
      const caoCao = blocks.find(block => block && block.type === BLOCK_TYPES.CAO_CAO);
      if (!caoCao) return;
      
      // Check if red block is in exit position (bottom center)
      if (caoCao.x === 1 && caoCao.y === 3) {
        console.log("Victory!");
        gameActive = false;
        
        // Stop timer
        if (timerInterval) {
          clearInterval(timerInterval);
          timerInterval = null;
        }
        
        // Show victory message
        victoryMoves.textContent = moveCount;
        victoryTime.textContent = timerDisplay.textContent;
        victoryMessage.classList.add('show');
      }
    }
    
    // Start timer
    function startTimer() {
      startTime = new Date();
      
      if (timerInterval) {
        clearInterval(timerInterval);
      }
      
      timerInterval = setInterval(() => {
        const now = new Date();
        const elapsed = Math.floor((now - startTime) / 1000);
        const minutes = Math.floor(elapsed / 60).toString().padStart(2, '0');
        const seconds = (elapsed % 60).toString().padStart(2, '0');
        timerDisplay.textContent = `${minutes}:${seconds}`;
      }, 1000);
    }
    
    // Undo previous move
    function undoMove() {
      if (moveHistory.length === 0 || !gameActive) return;
      
      console.log("Undoing previous move");
      
      const lastMove = moveHistory.pop();
      const block = blocks[lastMove.blockId];
      
      if (!block) {
        console.error("Undoing move: block doesn't exist");
        return;
      }
      
      // Move back to original position
      block.x = lastMove.fromX;
      block.y = lastMove.fromY;
      block.element.style.left = `${lastMove.fromX * CELL_SIZE}px`;
      block.element.style.top = `${lastMove.fromY * CELL_SIZE}px`;
      
      // Update movement count
      moveCount--;
      movesCount.textContent = moveCount;
    }
    
    // Show/hide rules panel
    function toggleRulesPanel() {
      rulesPanel.classList.toggle('show');
    }
    
    // Find movable blocks (for hint functionality)
    function findMovableBlocks() {
      const movableBlocks = [];
      
      blocks.forEach((block, index) => {
        if (!block) return;
        
        // Try four directions
        const directions = [
          {dx: 0, dy: -1, name: 'up'},
          {dx: 0, dy: 1, name: 'down'},
          {dx: -1, dy: 0, name: 'left'},
          {dx: 1, dy: 0, name: 'right'}
        ];
        
        for (const dir of directions) {
          const newX = block.x + dir.dx;
          const newY = block.y + dir.dy;
          
          // Check boundaries
          if (newX < 0 || newY < 0 || 
              newX + block.type.width > GRID_COLS || 
              newY + block.type.height > GRID_ROWS) {
            continue;
          }
          
          // Check collision
          let collision = false;
          for (let i = 0; i < blocks.length; i++) {
            if (i === index || !blocks[i]) continue;
            
            const otherBlock = blocks[i];
            
            if (newX < otherBlock.x + otherBlock.type.width &&
                newX + block.type.width > otherBlock.x &&
                newY < otherBlock.y + otherBlock.type.height &&
                newY + block.type.height > otherBlock.y) {
              collision = true;
              break;
            }
          }
          
          if (!collision) {
            movableBlocks.push({
              blockId: index,
              direction: dir.name
            });
            break; // Found a viable direction
          }
        }
      });
      
      return movableBlocks;
    }
    
    // Initialize event listeners
    startLayoutButton.addEventListener('click', () => {
      initLayout(layoutSelect.value);
    });
    
    resetButton.addEventListener('click', () => {
      initLayout(currentLayout);
    });
    
    undoButton.addEventListener('click', () => {
      undoMove();
    });
    
    playAgainButton.addEventListener('click', () => {
      initLayout(currentLayout);
    });
    
    rulesButton.addEventListener('click', toggleRulesPanel);
    closeRulesButton.addEventListener('click', toggleRulesPanel);
    
    // Hint functionality
    hintButton.addEventListener('click', () => {
      if (!gameActive) return;
      
      console.log("Hint functionality");
      
      // Red block highlight hint
      const caoCao = blocks.find(block => block && block.type === BLOCK_TYPES.CAO_CAO);
      if (caoCao) {
        caoCao.element.style.boxShadow = '0 0 10px 3px rgba(16, 185, 129, 0.7)';
      }
      
      // Find movable blocks
      const movableBlocks = findMovableBlocks();
      console.log("Movable blocks:", movableBlocks);
      
      // Highlight movable blocks
      movableBlocks.forEach(move => {
        const block = blocks[move.blockId];
        if (block) {
          block.element.style.boxShadow = '0 0 10px 3px rgba(56, 189, 248, 0.7)';
        }
      });
      
      // If no movable blocks found, show hint
      if (movableBlocks.length === 0) {
        alert("No movable blocks found, use undo feature to back one step");
      }
      
      // Hint highlight timeout
      setTimeout(() => {
        blocks.forEach(block => {
          if (block) {
            block.element.style.boxShadow = '';
          }
        });
        
        // Re-highlight current selected block
        if (selectedBlock !== null && blocks[selectedBlock]) {
          blocks[selectedBlock].element.style.boxShadow = '0 0 10px 3px rgba(250, 204, 21, 0.7)';
        }
      }, 1500);
    });
    
    // Output debugging information
    console.log("Page loaded, initializing game...");
    
    // Initialize game
    initLayout('horizontal-vertical');
  </script>
</body>
</html> 